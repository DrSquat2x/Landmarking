
---
title: "How to use the R package 'Landmarking'"
author: Isobel Barrott
date: "8th June 2021"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{How to use the R package 'Landmarking'}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r 1,echo=FALSE}
knitr::opts_chunk$set(cache=FALSE,collapse=TRUE, comment="#>")
```
##What is landmarking?

...

##Performing a landmarking analysis using the R package 'Landmarking'

Below is a step-by-step guide on how to use this package. The example used throughout looks at using risk assessments recorded at primary care practices to predict the 5-year risk of cardiovascular disease (CVD). This example is for the landmark time 60 years old. To create a full landmark model which allows for predictions at other ages, we need to fit a series of these landmark models. For example, repeating the process for landmark times 58 years old, 59 years old, 61 years old etc.

We will perform the landmarking analysis using both the LOCF and LME longitudinal models described above and compare the results of these two model.
The example involves competing risks in the form of the risk of death from other causes, and the cause-specific model will as the 
survival submodel.

### Exploring the datasets

First of all, let's take a look at the datasets we are going to analyse.

There are two datasets:

* `data_repeats` contains repeat measurements data from CVD risk assessments. Each row corresponds to a different assessment and an individual may have multiple assessments. The dataset contains information about an individual's ethnicity, smoking status, diabetes, deprivation score, diagnosis of atrial fibrillation, and standardised systolic blood pressure (SBP). These were recorded on the date specified in `response_date_sbp_stnd`. The standardised total cholesterol to high density lipoprotein (HDL) ratio is also recorded as part of the assessment but was recorded on the date specified in `response_date_tchdl_stnd`, which is up to a month after the other variables were measured.

* `data_outcomes` contains CVD event data, indicating the time and status of event that each individual experiences. There are three types of events: censoring (this is due to loss to follow-up or the end of the study on, indicated by status `0`), CVD event (indicated by status `1`), or death from other causes (indicated by status `2`). It is important when using this package that 0 is used to indicate censoring, 1 to indicate the event of interest, and values 2 or above indicate different competing risks.

Both datasets contain column `id` which specifies the patient identifier which is unique to a patient. 

```{r 2}
library(Landmarking)
set.seed(1)
head(data_repeat)
head(data_outcomes)
```

Looking further at these datasets we see that there are `r length(unique(data_repeat$id))` patients in this study, each with an average of `r mean(table(data_repeat$id))` assessments.

```{r 3}
length(unique(data_repeat$id)) 
mean(table(data_repeat$id))
```

Moreover, we can see the breakdown of events

```{r 4}
table(data_outcomes$event_status)
```

So `r length(which(data_outcomes$event_status==1))` patients in the study (out of 10000) experienced a CVD event and `r length(which(data_outcomes$event_status==2))` experienced death from other causes.


###Setting up the analysis

To use the Landmarking package, the datasets need to be in a certain format. Firstly, instead of the date of the CVD assessment being recorded, the age of the patient should be recorded.

```{r 5}
data_repeat$response_time_tchdl_stnd<-
    as.numeric((as.Date(data_repeat$response_date_tchdl_stnd,format="yyyy-mm-dd")-as.Date(data_repeat$dob,format="yyyy-mm-dd"))/365.25)
data_repeat$response_time_sbp_stnd<-
    as.numeric((as.Date(data_repeat$response_date_sbp_stnd,format="yyyy-mm-dd")-as.Date(data_repeat$dob,format="yyyy-mm-dd"))/365.25)
```

Secondly, the two datasets `data_repeat` and `data_outcomes` need to be combined so that they are contained within one data frame.

```{r 6}
data_repeat_outcomes<-dplyr::left_join(data_repeat,data_outcomes,by="id")
head(data_repeat_outcomes)
```

We are now ready to begin the analysis using the Landmarking package.

## Landmarking analysis

There are two steps to using this package:

1. Creating a dataset of individuals at risk (in folllow-up and without having experienced any event) at the landmark age.
1. Fitting the landmark model using `fit_LOCF_landmark_model` or `fit_LME_landmark_model`.

###  

To perform the first step, the function `create_landmark_dataset` selects the patients that at the landmark time have entered the study (defined as having had their first assessment) and have not been censored or had any events.

```{r 7}
data_landmark<-create_landmark_dataset(data=data_repeat_outcomes,
                                     x_L=60,
                                     assessment_time="response_time_sbp_stnd",
                                     patient_id="id",
                                     event_time="event_time",
                                     event_status="event_status")
length(unique(data_landmark$id))
```

So `r length(unique(data_landmark$id))` individuals are in the risk set at 60 years old.

It seems as though we are almost ready to perform the landmarking analysis using functions `fit_LOCF_landmark_model` and `fit_LME_landmark_model`. However, there are a couple of issues that stem from the fact we wish to compare the LOCF and LME longitudinal model. We want the same dataset to be used for both of these models to ensure that the comparison is fair. 

The first issue is the presence of `NA` values means that some individuals in the risk set do not have LOCF values for all the covariates. This means that the LOCF longitudinal model cannot be fitted for these individuals, however the LME longitudinal model can allow missing values in the random effects covariates. As we wish the dataset the both models are performed on to be the same, we should consider removing these individuals from the dataset.


Helpfully, the `Landmarking` package contains a function `return_ids_with_LOCF` to create a dataset with individuals with a LOCF for all covariates contained in the `covariates` parameter at landmark time `x_L`.

```{r 9}
data_landmark<-return_ids_with_LOCF(data=data_landmark,patient_id="id",covariates=c("ethnicity","smoking","diabetes","deprivation","atrial_fibrillation","sbp_stnd","tchdl_stnd"),covariates_time=c(rep("response_time_sbp_stnd",6),"response_time_tchdl_stnd"),x_L=60)
length(unique(data_landmark$id))
```

As there is only a small number of individuals (`r 7089-length(unique(data_landmark$id))`) with no LOCF for some covariates is probably best to leave them removed them from the dataset.

The second issue is related to cross-validation. In particular we wish to perform k-fold cross-validation using exactly the same folds for both models to ensure a fair comparison. The function `add_cv_number` assigns each individual in a dataset a k-fold cross-validation number which can then used when performing the `fit_LOCF_landmark_model` and `fit_LME_landmark_model` functions.

```{r 10}
data_landmark_cv<-add_cv_number(data=data_landmark, patient_id="id", k=10)
head(data_landmark_cv)
```

We have now completed the first step and are now ready to use `fit_LOCF_landmark_model` and `fit_LME_landmark_model` functions. Firstly, we fit the landmark model using the LOCF longitudinal submodel. For more information about this function, see the Details section of the `fit_LOCF_landmark_model` documentation.

```{r 11}
data_model_landmark_LOCF<-fit_LOCF_landmark_model(data=data_landmark_cv,
                                                      x_L=60,
                                                      x_hor=65,
                                                      covariates=c("ethnicity","smoking","diabetes","deprivation","atrial_fibrillation","sbp_stnd","tchdl_stnd"),
                                                      covariates_time=c(rep("response_time_sbp_stnd",6),"response_time_tchdl_stnd"),
                                                      cv_name="cross_validation_number",
                                                      patient_id="id",
                                                      event_time="event_time",
                                                      event_status="event_status",
                                                      survival_submodel = "cause_specific")
names(data_model_landmark_LOCF)
```

We can see that fitting this model returns the warning `Loglik converged before variable  12 ; coefficient may be infinite.` once for each of the cross-validation folds. Taking a look at the model fit contained in `data_model_landmark_LOCF$model_survival`, the upper confidence interval for the coefficient for atrial_fibrillation is `inf` for cause 2. This is due there being few individuals that have atrial_fibrillation and few individuals that experienced death from other causes. 

However, as only the point estimate of the coefficient is needed to calculate the risk prediction, not having the standard error is not a problem. Indeed we have obtained the risk predictions and can take a look at their distribution.


```{r 11}
plot(density(data_model_landmark_LOCF$data$event_prediction), xlab="Predicted risk of CVD event",main="")
```


Now we can move on to fitting the landmark model using the LME longitudinal submodel.  For more information about this function, see the Details section of the `fit_LME_landmark_model` documentation. The variables standardised systolic blood pressure (SBP) and standardised total cholesterol to high density lipoprotein (HDL) ratio are continous and repeatedly measured and so these can be included as random effects in the LME model.   

There are a couple of computational considerations to highlight about fitting the LME model. The parameter `lme_control` can be altered in order to change the 
default values of parameters (such as maximum number of iterations) for the algorithm which fits the LME model. Also setting `standardise_time = TRUE` standardises 
time values which helps fitting the LME model (see `help("fit_LME_landmark_model")`).

```{r 13}
data_model_landmark_LME<-fit_LME_landmark_model(data=data_landmark_cv,
                                                    x_L=60,
                                                    x_hor=65,
                                                    fixed_effects=c("ethnicity","smoking","diabetes","deprivation","atrial_fibrillation"),
                                                    fixed_effects_time="response_time_sbp_stnd",
                                                    random_effects=c("sbp_stnd","tchdl_stnd"),
                                                    random_effects_time=c("response_time_sbp_stnd","response_time_tchdl_stnd"),
                                                    cv_name="cross_validation_number",
                                                    patient_id="id",
                                                    standardise_time = TRUE,
                                                    lme_control = nlme::lmeControl(maxIter=100,msMaxIter=100),
                                                    event_time="event_time",
                                                    event_status="event_status",
                                                    survival_submodel = "cause_specific")
```

Usually, at this point we would perform the above analysis for further landmark times and their corresponding time horizons. However, this will be omitted in this vignette as it should now be clear how to do this.  

Finally, we need to calculate an evaluation metric to compare landmarking using LOCF and landmarking using LME. If we had fitted several landmarking models at different landmark times we could combine the `data` datasets from the above output and compute these metric on the overall dataset. Here we will just do it for landmark age 60. The function `get_model_assessment` computes the c-index and Brier score.

```{r 14}
data_landmark_LOCF<-data_model_landmark_LOCF$data
model_assessment_LOCF<-get_model_assessment(data=data_landmark_LOCF,
           patient_id="id",
           event_prediction="event_prediction",
           event_status="event_status",
           event_time="event_time",
           x_hor=65,
           return_c_index = TRUE,
           return_brier_score = TRUE,
           b=50,
           standard_error = TRUE)
```

```{r 15}
data_landmark_LME<-data_model_landmark_LME$data
model_assessment_LME<-get_model_assessment(data=data_landmark_LME,
           patient_id=patient_id_col,
           event_prediction="event_prediction",
           event_status="event_status",
           event_time="event_time",
           x_hor=x_hor,
           return_c_index = TRUE,
           return_brier_score = TRUE,
           b=50,
           standard_error = TRUE)
```





